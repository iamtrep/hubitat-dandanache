<!DOCTYPE html>
<html lang="en">
<head>
    <title>Hub-a-Dashery - v1.2.1</title>
    <meta charset="utf-8">
    <meta name="keywords" content="hubitat, memory, cpu">
    <meta name="author" content="Dan Danache">
    <meta name="description" content="View dashboards for your Hubitat hub metrics.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-title" content="Hub-a-Dashery"/>
    <meta name="application-name" content="Hub-a-Dashery"/>
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="/ui2/images/browserconfig.xml">
    <meta name="theme-color" content="#fdf6e3">
    <meta name="x5-orientation" content="portrait">
    <meta name="x5-page-mode" content="app">
    <meta name="screen-orientation" content="portrait">
    <meta name="browsermode" content="application">

    <link rel="apple-touch-icon" sizes="180x180" href="/ui2/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/ui2/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/ui2/images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/ui2/images/android-chrome-512x512.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/ui2/images/android-chrome-192x192.png">
    <link rel="icon" sizes="192x192" href="/ui2/images/favicon.ico">
    <link rel="manifest" href="./app.webmanifest?access_token=${access_token}">
    <link rel="mask-icon" href="/ui2/images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="/ui2/images/favicon.ico">
    <link rel="preconnect" href="//unpkg.com" crossorigin="anonymous" />
    <link rel="preconnect" href="//necolas.github.io" crossorigin="anonymous" />

    <link rel="stylesheet" type="text/css" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- Date handler -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

    <!-- Plugins -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-gauge-v3@3.0.0/dist/index.min.js"></script>

    <!-- Grid -->
    <script src="https://cdn.jsdelivr.net/npm/gridstack@10.1.0/dist/gridstack-all.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/gridstack@10.1.0/dist/gridstack.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/gridstack@10.1.0/dist/gridstack-extra.min.css" rel="stylesheet">

    <style>

    :root {
        --Base03: #002b36; /* background tones (dark) */
        --Base02: #073642; /* -- */
        --Base01: #586e75; /* content tones */
        --Base00: #657b83; /* -- */
        --Base0: #839496;  /* -- */
        --Base1: #93a1a1;  /* -- */
        --Base2: #eee8d5;  /* background tones (white) */
        --Base3: #fdf6e3;  /* -- */
        --Yellow: #b58900; /* accent tones */
        --Orange: #cb4b16;
        --Red: #dc322f;
        --Magenta: #d33682;
        --Violet: #6c71c4;
        --Blue: #268bd2;
        --Cyan: #2aa198;
        --Green: #859900;
        --Black: #000;

        --bg-color: var(--Base2);
        --bg-color-darker: var(--Base3);
        --text-color: var(--Base03);
        --text-color-darker: var(--Base00);
        --border-color: var(--Base0);
        --shadow-color: var(--Base1);
        --separator-color: var(--Base1);
        --Gray: var(--Base0);

        --tooltip-bg-color: var(--Base02);
        --tooltip-text-color: var(--Base2);
    }

    [data-theme="dark"] {
        --bg-color: var(--Base03);
        --bg-color-darker: var(--Base02);
        --text-color: var(--Base3);
        --text-color-darker: var(--Base1);
        --border-color: var(--Base00);
        --shadow-color: var(--Black);
        --separator-color: var(--Base01);
        --Gray: var(--Base01);

        --tooltip-bg-color: var(--Base2);
        --tooltip-text-color: var(--Base02);
    }

    body {
        margin: 0;
        padding: 0;
        font: 0.85rem sans-serif;
        background: var(--bg-color);
        color: var(--text-color);
        cursor: default;
    }

    html {
        -webkit-text-size-adjust: 100%;
    }

    a {
        text-decoration: none;
        color: var(--Blue);
    }

    /* Charts */
    .chart-container {
        height: 100%;
        position: relative;
    }

    .chart-container .chart-title {
        position: absolute;
        top: 0; left: 50%;
        transform: translate(-50%, 0);
        cursor: move;
        color: var(--text-color);
        background-color: transparent;
        text-align: center;
        padding: 0.2em 1em;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .chart-container .chart-title:hover {
        background-color: var(--bg-color);
        box-shadow: 0 0 .3em var(--shadow-color);
        border: 1px var(--border-color) solid;
        border-radius: 0 0 5px 5px;
        border-top: 0;
    }

    canvas {
        image-rendering: optimizeSpeed !important;             /* Older versions of FF          */
        image-rendering: -moz-crisp-edges !important;          /* FF 6.0+                       */
        image-rendering: -webkit-optimize-contrast !important; /* Safari                        */
        image-rendering: -o-crisp-edges !important;            /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated !important;                 /* Awesome future-browsers       */
        -ms-interpolation-mode: nearest-neighbor !important;   /* IE                            */
        box-sizing: initial !important;
    }

    .chart-container table {
        width: 100%;
        height: 100%;
        border-collapse: collapse;
        color: var(--text-color-darker);
        table-layout: fixed;
    }

    .chart-container table tr:first-child td {
        height: 20px;
        padding: 0;
        border: 0;
    }

    .chart-container table td {
        border-top: 1px var(--bg-color) solid;
        padding: 0 0.5em;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .chart-container table tr td:first-child {
        text-align: right;
        font-weight: bold;
    }

    /* Grid stack */
    .grid-stack {
        top: 0; right: 0; bottom: 0; bottom: 0;
        background: var(--bg-color);
    }
    .grid-stack-item-content {
        background-color: var(--bg-color-darker);
        color: var(--text-color);
        border: 1px var(--border-color) solid;
        border-radius: 5px;
        box-shadow: 0 0 .3em var(--shadow-color);
    }

    /* Mobile view */
    @media only screen and (max-width: 790px) {

    }
    </style>
</head>
<body>

    <div class="grid-stack"></div>

    <script type="text/javascript">
    class HubitatConnection {

        constructor(configuration) {
            this.accessToken = undefined;

            configuration.addEventListener('config', config => this.accessToken = config.accessToken);
        }

        init() {

            // Check Access Token
            if (this.accessToken === undefined) {
                throw new Error('HubitatConnection: Cannot find Access Token in URL');
            }
        }

        async getGridLayout() {
            console.info('Fetching Grid layout ...');
            return fetch(new Request(`./grid-layout.json?access_token=${this.accessToken}`), {cache: 'no-store'})
                .then((response) => {
                    if (!response.ok) {
                        console.error('HubitatConnection.getGridLayout() - Bad response (not 200 OK)', response);
                        throw new Error(`HubitatConnection.getGridLayout() - HTTP error, status = ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => JSON.parse(text));
        }

        async saveGridLayout(layout) {
            console.info('Saving Grid layout ...');
            return fetch(new Request(`./grid-layout.json?access_token=${this.accessToken}`), {
                method: 'PUT',
                body: JSON.stringify(layout),
                cache: 'no-store'
            })
                .then((response) => {
                    if (!response.ok) {
                        console.error('HubitatConnection.saveGridLayout() - Bad response (not 200 OK)', response);
                        throw new Error(`HubitatConnection.saveGridLayout() - HTTP error, status = ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => JSON.parse(text))
                .then(json => {
                    if (json.status !== true) {
                        console.error('HubitatConnection#saveGridLayout() - Bad status attribute (not true)', json);
                        throw new Error(`HubitatConnection#saveGridLayout() - JSON error, status = ${json.status}`);
                    }
                    return json;
                });
        }

        async fetchMemCpuHistory() {
            console.info('Fetching MEM/CPU history ...');
            return fetch(new Request('/hub/advanced/freeOSMemoryHistory'), {cache: 'no-store'})
            //return fetch(new Request('/local/freeOSMemoryHistory.txt'), {cache: 'no-store'})
                .then((response) => {
                    if (!response.ok) {
                        console.error('HubitatConnection.fetchMemCpuHistory() - Bad response (not 200 OK)', response);
                        throw new Error(`HubitatConnection.fetchMemCpuHistory() - HTTP error, status = ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => {
                    const lines = text.split("\n").filter(line => line !== '');
                    lines.shift();

                    // Count year resets
                    let yearResets = 0;
                    let prevLine = lines[0];
                    lines.forEach(line => {
                        if (line < prevLine) yearResets++;
                        prevLine = line;
                    });

                    const currYear = new Date().getFullYear();
                    prevLine = lines[0];
                    return lines.map(line => { // 02-24 00:35:14,611576,0.94
                        if (line < prevLine) yearResets--;
                        prevLine = line;

                        const bits = line.split(',');
                        return {
                            date: luxon.DateTime.fromFormat(`${bits[0].substring(0, 5)}-${currYear - yearResets} ${bits[0].substring(6, bits[0].length)}`, 'MM-dd-yyyy TT').ts,
                            mem: Math.round(parseInt(bits[1]) / 1024),
                            cpu: parseFloat(bits[2])
                        }
                    });
                })
                .catch((ex) => {
                    console.error('HubitatConnection.fetchMemCpuHistory() - Failed to fetch data', ex);
                    alert(`HubitatConnection.fetchMemCpuHistory() - Failed to fetch data: ${ex.message}`);
                });
        }

        async fetchMemCpuLast() {
            console.info('Fetching MEM/CPU ...');
            return fetch(new Request('/hub/advanced/freeOSMemoryLast'), {cache: 'no-store'})
                .then((response) => {
                    if (!response.ok) {
                        console.error('HubitatConnection.fetchMemCpuLast() - Bad response (not 200 OK)', response);
                        throw new Error(`HubitatConnection.fetchMemCpuLast() - HTTP error, status = ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => {
                    const bits = text.split("\n")[1].split(',');
                    return {
                        time: bits[0].split(' ')[1],
                        mem: Math.round(parseInt(bits[1]) / 1024),
                        cpu: Math.round(parseFloat(bits[2]) / 4 * 10000) / 100
                    };
                });
        }

        async fetchHubMetrics() {
            console.info('Fetching Hub metrics ...');
            return fetch(new Request(`./hub-metrics.json?access_token=${this.accessToken}`), {cache: 'no-store'})
                .then((response) => {
                    if (!response.ok) {
                        console.error('HubitatConnection.fetchHubMetrics() - Bad response (not 200 OK)', response);
                        throw new Error(`HubitatConnection.fetchHubMetrics() - HTTP error, status = ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => JSON.parse(text))
                .then(json => {
                    return json.map(hub => {
                        const dt = luxon.DateTime
                        const lastRestart = dt.now().minus({ seconds: hub.uptime }).setLocale(UI.locale())
                        return DeepMerge.merge(hub, {
                            alive: lastRestart.toRelative({ round: false }).replace(' ago', ''),
                            reboot: lastRestart.toLocaleString(dt.DATETIME_SHORT)
                        });
                    });
                });
        }
    }

    class Configuration {
        constructor() {
            this.accessToken = undefined;
            this.dark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Event listeners
            this.eventListeners = {};
        }

        addEventListener(eventName, callback) {
            if (!Array.isArray(this.eventListeners[eventName])) this.eventListeners[eventName] = [];
            this.eventListeners[eventName].push(callback);
        }

        init() {
            const params = new URLSearchParams(window.location.search);

            // Access Token
            const accessToken = params.get('access_token');
            if (accessToken != null) this.accessToken = accessToken;

            // Dark mode
            const darkTheme = params.get('dark');
            if (darkTheme != null) this.dark = darkTheme === 'true';

            // Notify outside world of the changes
            this.#onConfigChange();
        }

        #onConfigChange() {
            const eventName = 'config';
            if (!Array.isArray(this.eventListeners[eventName])) return;
            this.eventListeners[eventName].forEach(eventListener => eventListener(this));
        }
    }

    class DeepMerge {
        static merge(current, update) {
            Object.keys(update).forEach(key => {
                if (current.hasOwnProperty(key) && typeof current[key] === 'object' && !(current[key] instanceof Array)) {
                    DeepMerge.merge(current[key], update[key]);
                } else {
                    current[key] = update[key];
                }
            });
            return current;
        }
    }

    class ChartHelper {

        static crosshairPlugin() {
            return {
                id: 'crosshair',
                defaults: {
                    width: 1,
                    color: 'red',
                    dash: [2, 2],
                },
                afterInit: (chart, args, opts) => {
                    chart.crosshair = {
                        x: 0,
                        y: 0,
                    }
                },
                afterEvent: (chart, args) => {
                    const {inChartArea} = args
                    const {type,x,y} = args.event

                    chart.crosshair = {x, y, draw: inChartArea}
                    chart.draw()
                },
                beforeDatasetsDraw: (chart, args, opts) => {
                    const {ctx} = chart;
                    const {top, bottom, left, right} = chart.chartArea;
                    const {x, y, draw} = chart.crosshair;
                    if (!draw) return;

                    ctx.save();
                    ctx.beginPath();
                    ctx.lineWidth = opts.width;
                    ctx.strokeStyle = opts.color;
                    ctx.setLineDash(opts.dash);
                    ctx.moveTo(x, bottom);
                    ctx.lineTo(x, top);
                    //ctx.moveTo(left, y)
                    //ctx.lineTo(right, y)
                    ctx.stroke();
                    ctx.restore();
                }
            };
        }

        // Show/hide individual points depending on how many points are in view
        static updatePointStyle(chart) {
            if (chart.scales.x === undefined) return;
            const currentPointStyle = chart.data.datasets[0].pointStyle;
            const viewableInterval = chart.scales.x.ticks.slice(-1).pop().value - chart.scales.x.ticks[0].value;
            const newPointStyle = viewableInterval / chart.width > 30000 ? false : 'circle';
            if (newPointStyle !== currentPointStyle) {
                chart.data.datasets[0].pointStyle = newPointStyle;
                chart.update();
            }
        }

        static lineChartDefaults() {
            const colors = UI.colors();
            return {
                type: 'line',
                options: {
                    parsing: false,
                    normalized: true,
                    responsive: true,
                    maintainAspectRatio: false,
                    onResize: chart => ChartHelper.updatePointStyle(chart),
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 3
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                minUnit: 'minute',
                                displayFormats: {
                                    minute: 'd LLL T',
                                    hour: 'd LLL T',
                                    day: 'd LLL'
                                },
                                tooltipFormat: 'd LLL T'
                            },
                            title: { display: false },
                            ticks: {
                                color: colors.TextColorDarker,
                                maxRotation: 0,
                                autoSkipPadding: 15
                            },
                            grid: {
                                color: colors.BgColor
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: false,
                                color: colors.TextColor
                            },
                            ticks: {
                                color: colors.TextColorDarker
                            },
                            grid: {
                                color: colors.BgColor
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: colors.BgColorDarker,
                            titleColor: colors.TextColor,
                            bodyColor: colors.TextColorDarker,
                            borderColor: colors.BorderColor,
                            borderWidth: 1
                        },
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb'
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                            },
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x',
                                onZoomComplete: ({chart}) => ChartHelper.updatePointStyle(chart)
                            },
                            limits: {
                                x: {min: 'original', max: 'original'},
                            },
                        },
                        crosshair: {
                            color: colors.TextColorDarker,
                        }
                    }
                },
                plugins: [ ChartHelper.crosshairPlugin() ]
            }
        }

        static gaugeChartDefaults() {
            const colors = UI.colors();
            return {
                type: 'gauge',
                options: {
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20
                        }
                    },
                    needle: {
                        radius: '8%',
                        width: '10%',
                        length: '90%',
                        color: colors.TextColor
                    },
                    cutout: '65%',
                    valueLabel: {
                        display: true,
                        color: colors.TextColorDarker,
                        backgroundColor: colors.BgColorDarker,
                        borderWidth: 1,
                        borderRadius: 5,
                        borderColor: colors.BorderColor,
                        padding: {
                            top: 2, bottom: 2, left: 4, right: 4
                        },
                        offsetY: '-22%'
                    }
                }
            };
        }

        static createLineChart(elementId, config) {
            const element = document.getElementById(elementId);
            if (element === null) throw new Error(`Cannot find HTML chart canvas element "${elementId}"`);

            const chart = new Chart(element, DeepMerge.merge(ChartHelper.lineChartDefaults(), config));
            element.addEventListener('dblclick', evt => chart.resetZoom());
            //element.addEventListener('click', evt => { chart.options.plugins.decimation.enabled = !(chart.options.plugins.decimation.enabled); chart.update();});
            //chart.canvas.style.touchAction = "pan-y";
            return chart;
        }

        static createGaugeChart(elementId, config) {
            const element = document.getElementById(elementId);
            if (element === null) throw new Error(`Cannot find HTML chart canvas element "${elementId}"`);

            const chart = new Chart(element, DeepMerge.merge(ChartHelper.gaugeChartDefaults(), config));
            return chart;
        }
    }

    class MemCpuHistoryChart {
        constructor(connection) {
            this.connection = connection;

            this.memChart = undefined;
            this.cpuChart = undefined;
        }

        async metadata() {
            return Promise.resolve({
                'mem-history': { w: 6, h: 1, title: 'Free OS Memory' },
                'cpu-history': { w: 6, h: 1, title: 'CPU Load Average' }
            });
        }

        async load() {
            const colors = UI.colors();
            return this.connection.fetchMemCpuHistory().then(history => {
                this.memChart = ChartHelper.createLineChart('mem-history', {
                    data: {
                        datasets: [{
                            label: 'Free memory',
                            data: history.map(record => { return {'x': record.date, 'y': record.mem } }),
                            pointStyle: false,
                            backgroundColor: colors.Green + '44',
                            borderColor: colors.Green,
                            borderWidth: 1.2,
                            tension: 0.5,
                            fill: 'start'
                        }]
                    },
                    options: {
                        pointStyle: false,
                        scales: {
                            y: {
                                title: {
                                    text: 'Memory'
                                },
                                ticks: {
                                    callback: label => `${(label).toLocaleString(UI.locale(), { style: 'unit', unit: 'megabyte'}) }`
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: t => `${t.dataset.label}: ${(t.parsed.y).toLocaleString(UI.locale(), { style: 'unit', unit: 'megabyte'}) }`
                                }
                            },
                            annotation: {
                                annotations: {
                                    lowMemoryWarning: {
                                        type: 'line',
                                        yMin: 80,
                                        yMax: 80,
                                        borderColor: colors.Red,
                                        borderWidth: 1,
                                        borderDash: [2, 2]
                                    }
                                }
                            }
                        }
                    }
                });

                this.cpuChart = ChartHelper.createLineChart('cpu-history', {
                    data: {
                        datasets: [{
                            fill: 'start',
                            label: 'Load average',
                            data: history.map(record => { return {'x': record.date, 'y': record.cpu } }),
                            pointStyle: false,
                            backgroundColor: colors.Blue + '44',
                            borderColor: colors.Blue,
                            borderWidth: 1.2,
                            tension: 0.5,
                            fill: 'start'
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                title: {
                                    text: 'CPU'
                                }
                            }
                        },
                        plugins: {
                            annotation: {
                                annotations: {
                                    highLoad: {
                                        type: 'line',
                                        yMin: 1,
                                        yMax: 1,
                                        borderColor: colors.Red,
                                        borderWidth: 1,
                                        borderDash: [2, 2]
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }
    }

    class MemCpuLastChart {
        constructor(connection) {
            this.connection = connection;

            this.memChart = undefined;
            this.cpuChart = undefined;
            this.memTitleElement = undefined;
            this.cpuTitleElement = undefined;
            this.refreshInterval = undefined;
        }

        async metadata() {
            return Promise.resolve({
                'mem-last': { w: 2, h: 1, title: 'Free OS Memory' },
                'cpu-last': { w: 2, h: 1, title: 'CPU Load' }
            });
        }

        async load() {
            const colors = UI.colors();
            this.memTitleElement = document.getElementById('mem-last-title');
            this.cpuTitleElement = document.getElementById('cpu-last-title');

            return this.connection.fetchMemCpuLast().then(data => {
                this.memChart = ChartHelper.createGaugeChart('mem-last', {
                    data: {
                        datasets: [{
                            value: data.mem,
                            minValue: 0,
                            data: [80, 200, 1024],
                            backgroundColor: [colors.Orange, colors.Yellow, colors.Green],
                            borderColor: 'transparent',
                        }]
                    },
                    options: {
                        valueLabel: {
                            formatter: (value) => {
                                return `${(value).toLocaleString(UI.locale(), { style: 'unit', unit: 'megabyte'}) }`
                            }
                        }
                    }
                });

                this.cpuChart = ChartHelper.createGaugeChart('cpu-last', {
                    data: {
                        datasets: [{
                            value: data.cpu,
                            minValue: 0,
                            data: [75, 90, 100],
                            backgroundColor: [colors.Green, colors.Yellow, colors.Orange],
                            borderColor: 'transparent',
                        }]
                    },
                    options: {
                        valueLabel: {
                            formatter: (value) => {
                                return `${(value.toFixed(2))}%`
                            }
                        }
                    }
                });

                this.#updateTitle(data.time);

                // Set auto-refresh every 1 minute
                this.refreshInterval = setInterval(() => this.refresh(), 1 * 60 * 1000);
            });
        }

        async refresh() {
            const data = await this.connection.fetchMemCpuLast();
            
            this.memChart.data.datasets[0].value = data.mem;
            this.cpuChart.data.datasets[0].value = data.cpu;

            this.memChart.update();
            this.cpuChart.update();
            this.#updateTitle(data.time);
        }

        async #updateTitle(time) {
            const metadata = await this.metadata();
            this.memTitleElement.innerText = `${metadata['mem-last'].title} @ ${time}`;
            this.cpuTitleElement.innerText = `${metadata['cpu-last'].title} @ ${time}`;
        }
    }

    class TableChart {
        constructor(connection) {
            this.connection = connection;

            this.table = undefined;
            this.hubMetrics = undefined;
        }

        async metadata() {
            if (this.hubMetrics === undefined) {
                this.hubMetrics = await this.connection.fetchHubMetrics();
            }

            const retVal = {};
            this.hubMetrics.forEach(hub => {
                retVal[hub.name] = { w: 2, h: 1, title: hub.name }
            });
            return Promise.resolve(retVal);
        }

        async load() {
            this.hubMetrics.forEach(hub => {
                const id = hub.name;
                const canvas = document.getElementById(id)
                const parentElement = canvas.parentElement
                parentElement.removeChild(canvas)
                
                const tbl = document.createElement('table')
                tbl.setAttribute('id', id)
                const tblBody = document.createElement('tbody')
                tbl.appendChild(tblBody)
                parentElement.appendChild(tbl)

                tblBody.appendChild(this.#buildRow())
                tblBody.appendChild(this.#buildRow('IP Address', hub.ip))
                tblBody.appendChild(this.#buildRow('FW Ver', hub.fw))
                tblBody.appendChild(this.#buildRow('Uptime', hub.alive))
                tblBody.appendChild(this.#buildRow('Reboot', hub.reboot))
            });

            // Set auto-refresh every 5 minutes
            this.refreshInterval = setInterval(() => this.refresh(), 5 * 60 * 1000);
        }

        async refresh() {
            this.hubMetrics = await this.connection.fetchHubMetrics();
            this.hubMetrics.forEach(hub => {
                const tbl = document.getElementById(hub.name);
                if (tbl === null) return console.log('I do not know this hub, it is no friend of mine:', hub.name)
                tbl.rows[1].cells[1].innerText = hub.ip
                tbl.rows[2].cells[1].innerText = hub.fw
                tbl.rows[3].cells[1].innerText = hub.alive
                tbl.rows[4].cells[1].innerText = hub.reboot
            });
        }

        #buildRow(label, value) {
            const row = document.createElement('tr')
            let cell = document.createElement('td')
            cell.appendChild(document.createTextNode(label === undefined ? '' : label))
            row.appendChild(cell)

            if (label === undefined) {
                cell.setAttribute('colspan', 3)
            } else {
                cell.setAttribute('title', label)
                cell = document.createElement('td')
                cell.setAttribute('title', value)
                cell.setAttribute('colspan', 2)
                cell.appendChild(document.createTextNode(value))
            }

            row.appendChild(cell)
            return row
        }
    }

    class Grid {
        constructor(connection) {
            this.connection = connection;

            this.layout = undefined;
            this.grid = undefined;
        }

        async init() {
            this.layout = await this.connection.getGridLayout();
            if (this.layout.widgets === undefined) this.layout.widgets = {};
            console.log('gridLayout', this.layout);

            // Init grid
            this.grid = GridStack.init({
                sizeToContent: false,
                float: true,

                // Non-configurable options
                cellHeight: 206, //'25vh',
                column: 8,
                columnOpts: {
                    layout: 'move', // moveScale move scale list compact none
                    columnMax: 8,
                    breakpointForWindow: true,

                    // TODO: fiddle with these until it behaves nicely on mobile/tablet/laptop
                    breakpoints: [{w:420, c:1}, {w:800, c:2}, {w:1024, c:4}, {w:1366, c:6}]
                },
                float: true,
                handle: '.chart-title'
            });

            // Save grid changes to the Hub
            //this.grid.on('change', () => this.saveLayout());
        }

        async addChart(chart) {
            Object.entries(await chart.metadata()).forEach(([chartId, chartDefaults]) => {
                const chartLayout = this.layout.widgets[chartId];
                this.grid.addWidget(DeepMerge.merge(chartDefaults, {
                    content: `<div id="${chartId}-container" class="chart-container"><div id="${chartId}-title" class="chart-title">${chartDefaults.title}</div><canvas id="${chartId}"></canvas></div>`,
                    id: chartId,
                    ...chartLayout
                }));
            });
        }

        async saveLayout() {
            console.info('Saving layout', this.grid);
            const newLayout = { widgets: {} };
            this.grid.engine.nodes.forEach(node => {
                newLayout.widgets[node.id] = {
                    x: node.x, y: node.y, w: node.w, h: node.h
                }
            });

            this.layout = newLayout;
            return this.connection.saveGridLayout(newLayout);
        }
    }

    class UI {
        static colors() {
            const css = getComputedStyle(document.documentElement);
            return {
                BgColor: css.getPropertyValue('--bg-color'),
                BgColorDarker: css.getPropertyValue('--bg-color-darker'),
                TextColor: css.getPropertyValue('--text-color'),
                TextColorDarker: css.getPropertyValue('--text-color-darker'),
                BorderColor: css.getPropertyValue('--border-color'),
                Yellow: css.getPropertyValue('--Yellow'),
                Orange: css.getPropertyValue('--Orange'),
                Red: css.getPropertyValue('--Red'),
                Magenta: css.getPropertyValue('--Magenta'),
                Violet: css.getPropertyValue('--Violet'),
                Blue: css.getPropertyValue('--Blue'),
                Cyan: css.getPropertyValue('--Cyan'),
                Green: css.getPropertyValue('--Green'),
                Gray: css.getPropertyValue('--Gray')
            };
        }

        static locale() {
            return Intl.NumberFormat().resolvedOptions().locale;
        }

        constructor(configuration) {

            // Setup event handlers
            configuration.addEventListener('config', config => this.#repaintConfiguration(config));
        }

        applyConfiguration() {
            var searchParams = new URLSearchParams();

            const params = new URLSearchParams(window.location.search);
            const accessToken = params.get('access_token');
            if (accessToken) searchParams.set('access_token', accessToken);

            var goto = window.location.pathname + '?' + searchParams.toString();
            history.pushState(null, '', goto);
        }

        #repaintConfiguration(config) {
            document.documentElement.setAttribute('data-theme', config.dark ? 'dark' : 'light');
            document.querySelector('meta[name="theme-color"]').setAttribute('content',  UI.colors().BgColorDarker);
        }
    }

    /////////////////////////////////////////////////////////////////
    // Entry point
    /////////////////////////////////////////////////////////////////

    // Init instances
    const configuration = new Configuration();
    const hubitatConnection = new HubitatConnection(configuration);
    const ui = new UI(configuration);
    const grid = new Grid(hubitatConnection);

    // Init charts
    const memCpuHistoryChart = new MemCpuHistoryChart(hubitatConnection);
    const memCpuLastChart = new MemCpuLastChart(hubitatConnection)
    const tableChart = new TableChart(hubitatConnection)

    // Run application on page load
    window.addEventListener('load', () => run());

    // Helper functions
    async function saveGrid() {
        await grid.saveLayout();
        alert('Grid layout saved to Hub!');
    }

    async function run() {
        try {
            configuration.init();
            hubitatConnection.init();
        } catch (ex) {
            alert(ex.message);
            return;
        }

        // Init grid (async as it loads its config from the Hub)
        await grid.init();

        // Place charts into the grid
        await grid.addChart(memCpuHistoryChart);
        await grid.addChart(memCpuLastChart);
        await grid.addChart(tableChart);

        // Render charts
        await memCpuHistoryChart.load()
        await memCpuLastChart.load()
        await tableChart.load()

        // Setup Ctrl + S keyboard binding
        document.addEventListener('keydown', event => {
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault();
                saveGrid();
            }
        });
    }
    </script>
</body>
</html>
